# 第1章: Minecraft 协议基础知识

## 1.1 什么是网络协议?

想象你要给朋友写信:
- 你需要知道信封的格式(地址写在哪里)
- 你需要知道信的内容怎么写
- 朋友收到信后,需要按照约定的方式理解你的内容

**网络协议就是计算机之间"写信"的规则**。

## 1.2 Minecraft 协议是什么?

Minecraft 客户端和服务器之间通过网络通信,它们使用一套特定的规则:
- 客户端发送"我想登录"的消息
- 服务器回复"欢迎,你的位置在这里"
- 客户端发送"我移动到了新位置"
- 服务器回复"收到,这是周围的世界数据"

这些消息的格式和规则,就是 **Minecraft 协议**。

## 1.3 TCP/IP 基础

### 什么是 TCP?

TCP 就像打电话:
1. 你拨号(建立连接)
2. 对方接听(连接成功)
3. 你们对话(发送数据)
4. 挂断电话(关闭连接)

**特点**:
- 可靠:数据一定会到达,不会丢失
- 有序:数据按发送顺序到达
- 面向连接:需要先建立连接

### Java 中的 TCP 编程

```java
// 创建连接到服务器的 Socket
Socket socket = new Socket("localhost", 25565);

// 获取输入流(接收数据)
InputStream input = socket.getInputStream();

// 获取输出流(发送数据)
OutputStream output = socket.getOutputStream();

// 发送数据
output.write(new byte[]{1, 2, 3});

// 接收数据
byte[] buffer = new byte[1024];
int length = input.read(buffer);

// 关闭连接
socket.close();
```

**解释**:
- `Socket`: 就像一个电话机,用来连接服务器
- `InputStream`: 就像听筒,用来接收数据
- `OutputStream`: 就像话筒,用来发送数据
- `25565`: Minecraft 默认端口号(就像电话号码)

## 1.4 Minecraft 协议的层次结构

```
应用层: Minecraft 数据包 (PacketJoinGame, PacketKeepAlive...)
    ↓
协议层: 数据包格式 (长度 + ID + 数据)
    ↓
传输层: TCP 连接
    ↓
网络层: IP 协议
    ↓
物理层: 网线/WiFi
```

**我们要实现的是应用层和协议层**。

## 1.5 Minecraft 数据包格式

### 基本格式

```
[数据包长度] [数据包ID] [数据内容]
```

**例子**: 发送一个 KeepAlive 数据包

```
原始数据:
数据包ID = 0x00 (KeepAlive)
KeepAlive ID = 12345

编码后:
[长度: 6] [ID: 0x00] [KeepAlive ID: 12345]
```

### VarInt 编码

Minecraft 使用一种特殊的整数编码方式叫 **VarInt**。

**为什么需要 VarInt?**
- 普通 int 占 4 字节,即使数字很小(如 1)也占 4 字节
- VarInt 可以让小数字占用更少的字节

**编码规则**:
- 每个字节的最高位(第8位)表示"是否还有后续字节"
- 其余7位存储实际数据

**例子**:

```
数字 1:
二进制: 00000001
VarInt: 00000001 (1字节)

数字 300:
二进制: 00000001 00101100
VarInt: 10101100 00000010 (2字节)
        ↑        ↑
        还有后续  最后一个字节
```

**Java 实现**:

```java
// 写入 VarInt
public void writeVarInt(int value) throws IOException {
    // 循环处理每7位
    while ((value & -128) != 0) {
        // 取低7位,最高位设为1(表示还有后续)
        output.writeByte(value & 127 | 128);
        // 右移7位,处理下一组
        value >>>= 7;
    }
    // 写入最后一个字节(最高位为0)
    output.writeByte(value);
}

// 读取 VarInt
public int readVarInt() throws IOException {
    int value = 0;      // 结果值
    int position = 0;   // 当前处理的位位置
    byte currentByte;

    while (true) {
        currentByte = input.readByte();
        // 取低7位,放到对应位置
        value |= (currentByte & 127) << position;

        // 如果最高位是0,说明结束了
        if ((currentByte & 128) == 0) break;

        position += 7;  // 移动到下一组7位

        // 防止无限循环
        if (position >= 32) throw new RuntimeException("VarInt is too big");
    }

    return value;
}
```

**详细解释**:

1. **写入过程**:
   ```java
   写入数字 300:

   第一次循环:
   value = 300 (二进制: 100101100)
   value & 127 = 44 (取低7位: 0101100)
   value & 127 | 128 = 172 (加上最高位1: 10101100)
   写入: 172
   value >>>= 7 → value = 2 (右移7位)

   第二次循环:
   value = 2 (二进制: 10)
   value & -128 = 0 (不满足循环条件)
   写入: 2

   结果: [172, 2]
   ```

2. **读取过程**:
   ```java
   读取 [172, 2]:

   第一次循环:
   currentByte = 172 (二进制: 10101100)
   currentByte & 127 = 44 (取低7位)
   value = 44 << 0 = 44
   最高位是1,继续

   第二次循环:
   currentByte = 2 (二进制: 00000010)
   currentByte & 127 = 2
   value |= 2 << 7 = 44 | 256 = 300
   最高位是0,结束

   结果: 300
   ```

## 1.6 字符串编码

Minecraft 使用 UTF-8 编码字符串,格式是:

```
[字符串长度(VarInt)] [UTF-8字节数据]
```

**例子**: 发送字符串 "Hello"

```java
// 写入字符串
public void writeString(String value) throws IOException {
    // 1. 将字符串转为 UTF-8 字节数组
    byte[] bytes = value.getBytes(StandardCharsets.UTF_8);

    // 2. 写入长度(使用 VarInt)
    writeVarInt(bytes.length);

    // 3. 写入字节数据
    output.write(bytes);
}

// 读取字符串
public String readString() throws IOException {
    // 1. 读取长度
    int length = readVarInt();

    // 2. 读取字节数据
    byte[] bytes = new byte[length];
    input.read(bytes);

    // 3. 转换为字符串
    return new String(bytes, StandardCharsets.UTF_8);
}
```

**实际例子**:

```
字符串 "Hello":
UTF-8 字节: [72, 101, 108, 108, 111]
长度: 5

编码后:
[5] [72, 101, 108, 108, 111]
 ↑   ↑
 长度 实际数据
```

## 1.7 Minecraft 协议状态机

Minecraft 协议有4个状态:

```
1. HANDSHAKING (握手)
   ↓
2. STATUS (状态查询) 或 LOGIN (登录)
   ↓
3. PLAY (游戏中)
```

**状态转换**:

```java
public enum ProtocolState {
    HANDSHAKING(0),  // 初始状态
    STATUS(1),       // 查询服务器状态
    LOGIN(2),        // 登录流程
    PLAY(3);         // 游戏中

    private final int id;

    ProtocolState(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }
}
```

**状态说明**:

1. **HANDSHAKING**:
   - 客户端发送第一个数据包
   - 告诉服务器"我想做什么"(查询状态或登录)

2. **STATUS**:
   - 用于服务器列表
   - 查询服务器信息(在线人数、MOTD等)

3. **LOGIN**:
   - 登录流程
   - 可能包含加密、压缩设置

4. **PLAY**:
   - 游戏中的所有操作
   - 移动、聊天、方块交互等

## 1.8 数据包结构

每个数据包都有:
- **数据包ID**: 标识这是什么类型的数据包
- **数据内容**: 具体的数据

**例子**: KeepAlive 数据包

```java
public class PacketKeepAlive implements Packet {
    private int keepAliveId;  // 数据内容

    @Override
    public int getPacketId() {
        return 0x00;  // 数据包ID
    }

    @Override
    public void write(PacketBuffer buffer) throws IOException {
        // 写入数据
        buffer.writeVarInt(keepAliveId);
    }

    @Override
    public void read(PacketBuffer buffer) throws IOException {
        // 读取数据
        this.keepAliveId = buffer.readVarInt();
    }
}
```

## 1.9 完整的数据包发送流程

```
1. 创建数据包对象
   PacketKeepAlive packet = new PacketKeepAlive(12345);

2. 序列化数据包
   [ID: 0x00] [KeepAlive ID: 12345]

3. 计算长度
   长度 = 1 (ID) + 3 (KeepAlive ID的VarInt编码)

4. 发送
   [长度: 4] [ID: 0x00] [KeepAlive ID: 12345]
```

**Java 代码**:

```java
public void sendPacket(Packet packet) throws IOException {
    // 1. 创建缓冲区
    PacketBuffer buffer = new PacketBuffer();

    // 2. 写入数据包ID
    buffer.writeVarInt(packet.getPacketId());

    // 3. 写入数据包内容
    packet.write(buffer);

    // 4. 获取字节数组
    byte[] data = buffer.toByteArray();

    // 5. 写入长度
    PacketBuffer lengthBuffer = new PacketBuffer();
    lengthBuffer.writeVarInt(data.length);

    // 6. 发送长度和数据
    output.write(lengthBuffer.toByteArray());
    output.write(data);
    output.flush();
}
```

## 1.10 小结

**核心概念**:
1. TCP 连接: 客户端和服务器之间的通信通道
2. VarInt: 可变长度整数编码,节省空间
3. 数据包: 格式为 [长度][ID][数据]
4. 协议状态: HANDSHAKING → LOGIN → PLAY
5. 序列化: 将对象转换为字节流
6. 反序列化: 将字节流转换为对象

**下一章预告**:
我们将开始编写代码,实现 PacketBuffer 类,这是所有数据包序列化的基础!

---

## 练习题

1. 用 VarInt 编码数字 127,结果是多少字节?
2. 字符串 "Hi" 的 UTF-8 编码是什么?完整的数据包格式是什么?
3. 为什么需要在数据包前面加上长度?

**答案**:
1. 127 的二进制是 01111111,VarInt 编码是 [127],占1字节
2. "Hi" 的 UTF-8 是 [72, 105],完整格式是 [2, 72, 105]
3. 因为接收方需要知道要读取多少字节,否则不知道数据包在哪里结束
