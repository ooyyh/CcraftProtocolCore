# 第3章: 数据包系统设计

## 3.1 什么是数据包?

想象你要寄快递:
- 每个快递都有一个**单号**(数据包ID)
- 快递里面装着**物品**(数据内容)
- 快递员根据单号知道这是什么类型的快递

**Minecraft 数据包就是这样的"快递"**。

## 3.2 数据包的组成

每个数据包包含:
1. **数据包ID**: 标识这是什么类型的数据包
2. **数据内容**: 具体的数据

```
[数据包ID] [数据内容]
```

**例子**:

```
KeepAlive 数据包:
ID: 0x00
内容: KeepAlive ID (一个整数)

完整格式:
[0x00] [12345]
```

## 3.3 设计数据包接口

### 为什么需要接口?

接口就像一个"合同",规定了所有数据包必须实现的方法:
- 所有数据包都要能写入数据
- 所有数据包都要能读取数据
- 所有数据包都要有一个ID

### 创建 Packet 接口

```java
package protocol;

import java.io.IOException;

public interface Packet {
    // 写入数据到缓冲区
    void write(PacketBuffer buffer) throws IOException;

    // 从缓冲区读取数据
    void read(PacketBuffer buffer) throws IOException;

    // 获取数据包ID
    int getPacketId();
}
```

**详细解释**:

1. **write 方法**:
   - 将数据包的内容写入到 PacketBuffer
   - 发送数据包时调用

2. **read 方法**:
   - 从 PacketBuffer 读取数据到数据包对象
   - 接收数据包时调用

3. **getPacketId 方法**:
   - 返回这个数据包的ID
   - 用于识别数据包类型

## 3.4 实现第一个数据包: PacketKeepAlive

### KeepAlive 是什么?

KeepAlive 就像心跳:
- 服务器定期发送 KeepAlive 给客户端
- 客户端必须立即回复相同的 KeepAlive
- 如果客户端不回复,服务器会认为客户端掉线

### KeepAlive 数据包格式

```
客户端 → 服务器:
[数据包ID: 0x00] [KeepAlive ID: VarInt]

服务器 → 客户端:
[数据包ID: 0x00] [KeepAlive ID: VarInt]
```

### 实现代码

```java
package protocol.packets.play;

import protocol.Packet;
import protocol.PacketBuffer;

import java.io.IOException;

public class PacketKeepAlive implements Packet {
    // 数据内容: KeepAlive ID
    private int keepAliveId;

    // 构造函数1: 创建空的数据包(用于接收)
    public PacketKeepAlive() {}

    // 构造函数2: 创建带数据的数据包(用于发送)
    public PacketKeepAlive(int keepAliveId) {
        this.keepAliveId = keepAliveId;
    }

    @Override
    public void write(PacketBuffer buffer) throws IOException {
        // 写入 KeepAlive ID
        buffer.writeVarInt(keepAliveId);
    }

    @Override
    public void read(PacketBuffer buffer) throws IOException {
        // 读取 KeepAlive ID
        this.keepAliveId = buffer.readVarInt();
    }

    @Override
    public int getPacketId() {
        // 在 PLAY 状态下,KeepAlive 的 ID 是 0x00
        return 0x00;
    }

    // Getter 方法
    public int getKeepAliveId() {
        return keepAliveId;
    }
}
```

**逐行解释**:

```java
private int keepAliveId;
```
- 存储 KeepAlive ID
- 这是数据包的唯一数据

```java
public PacketKeepAlive() {}
```
- 无参构造函数
- 用于接收数据包时创建空对象
- 然后调用 read() 填充数据

```java
public PacketKeepAlive(int keepAliveId) {
    this.keepAliveId = keepAliveId;
}
```
- 有参构造函数
- 用于发送数据包时创建对象
- 直接设置数据

```java
@Override
public void write(PacketBuffer buffer) throws IOException {
    buffer.writeVarInt(keepAliveId);
}
```
- 将 keepAliveId 写入缓冲区
- 发送数据包时调用

```java
@Override
public void read(PacketBuffer buffer) throws IOException {
    this.keepAliveId = buffer.readVarInt();
}
```
- 从缓冲区读取 keepAliveId
- 接收数据包时调用

```java
@Override
public int getPacketId() {
    return 0x00;
}
```
- 返回数据包ID
- 0x00 是 KeepAlive 在 PLAY 状态下的ID

### 使用示例

```java
// 发送 KeepAlive
PacketKeepAlive packet = new PacketKeepAlive(12345);
PacketBuffer buffer = new PacketBuffer();
buffer.writeVarInt(packet.getPacketId());  // 写入ID
packet.write(buffer);                       // 写入数据
byte[] data = buffer.toByteArray();
// 发送 data...

// 接收 KeepAlive
byte[] receivedData = ...; // 从网络接收
PacketBuffer buffer = new PacketBuffer(receivedData);
int packetId = buffer.readVarInt();        // 读取ID
PacketKeepAlive packet = new PacketKeepAlive();
packet.read(buffer);                        // 读取数据
System.out.println("KeepAlive ID: " + packet.getKeepAliveId());
```

## 3.5 实现更复杂的数据包: PacketHandshake

### Handshake 是什么?

Handshake 是客户端发送的第一个数据包:
- 告诉服务器协议版本
- 告诉服务器地址和端口
- 告诉服务器下一步要做什么(查询状态或登录)

### Handshake 数据包格式

```
[数据包ID: 0x00]
[协议版本: VarInt]
[服务器地址: String]
[服务器端口: Unsigned Short]
[下一个状态: VarInt]
```

**例子**:

```
协议版本: 47 (Minecraft 1.8.9)
服务器地址: "localhost"
服务器端口: 25565
下一个状态: 2 (LOGIN)

编码后:
[0x00] [47] [9, 'l','o','c','a','l','h','o','s','t'] [25565] [2]
```

### 实现代码

```java
package protocol.packets.handshake;

import protocol.Packet;
import protocol.PacketBuffer;

import java.io.IOException;

public class PacketHandshake implements Packet {
    // 数据内容
    private int protocolVersion;    // 协议版本
    private String serverAddress;   // 服务器地址
    private int serverPort;         // 服务器端口
    private int nextState;          // 下一个状态

    // 构造函数1: 用于接收
    public PacketHandshake() {}

    // 构造函数2: 用于发送
    public PacketHandshake(int protocolVersion, String serverAddress,
                          int serverPort, int nextState) {
        this.protocolVersion = protocolVersion;
        this.serverAddress = serverAddress;
        this.serverPort = serverPort;
        this.nextState = nextState;
    }

    @Override
    public void write(PacketBuffer buffer) throws IOException {
        // 按顺序写入所有字段
        buffer.writeVarInt(protocolVersion);
        buffer.writeString(serverAddress);
        buffer.writeShort(serverPort);
        buffer.writeVarInt(nextState);
    }

    @Override
    public void read(PacketBuffer buffer) throws IOException {
        // 按相同顺序读取所有字段
        this.protocolVersion = buffer.readVarInt();
        this.serverAddress = buffer.readString();
        this.serverPort = buffer.readShort();
        this.nextState = buffer.readVarInt();
    }

    @Override
    public int getPacketId() {
        // Handshake 的 ID 是 0x00
        return 0x00;
    }

    // Getter 方法
    public int getProtocolVersion() {
        return protocolVersion;
    }

    public String getServerAddress() {
        return serverAddress;
    }

    public int getServerPort() {
        return serverPort;
    }

    public int getNextState() {
        return nextState;
    }
}
```

**重要提示**:

1. **字段顺序很重要**:
   - write 和 read 的顺序必须完全一致
   - 否则会读取错误的数据

2. **数据类型要匹配**:
   - 协议规定用 VarInt 就用 VarInt
   - 协议规定用 String 就用 String

### 使用示例

```java
// 创建 Handshake 数据包
PacketHandshake handshake = new PacketHandshake(
    47,           // 协议版本 (Minecraft 1.8.9)
    "localhost",  // 服务器地址
    25565,        // 服务器端口
    2             // 下一个状态 (LOGIN)
);

// 序列化
PacketBuffer buffer = new PacketBuffer();
buffer.writeVarInt(handshake.getPacketId());
handshake.write(buffer);

// 获取字节数组
byte[] data = buffer.toByteArray();

// 打印数据
System.out.println("Handshake 数据包:");
for (byte b : data) {
    System.out.print((b & 0xFF) + " ");
}
```

## 3.6 协议状态枚举

### 为什么需要状态?

Minecraft 协议有不同的阶段:
1. 握手阶段
2. 登录阶段
3. 游戏阶段

不同阶段的数据包ID可能相同,但含义不同。

### 实现 ProtocolState

```java
package protocol;

public enum ProtocolState {
    HANDSHAKING(0),  // 握手状态
    STATUS(1),       // 状态查询
    LOGIN(2),        // 登录状态
    PLAY(3);         // 游戏状态

    private final int id;

    ProtocolState(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    // 根据ID获取状态
    public static ProtocolState fromId(int id) {
        for (ProtocolState state : values()) {
            if (state.id == id) {
                return state;
            }
        }
        return null;
    }
}
```

**详细解释**:

```java
public enum ProtocolState {
    HANDSHAKING(0),
    STATUS(1),
    LOGIN(2),
    PLAY(3);
```
- 定义4个状态
- 每个状态有一个ID

```java
private final int id;

ProtocolState(int id) {
    this.id = id;
}
```
- 存储状态ID
- 构造函数设置ID

```java
public static ProtocolState fromId(int id) {
    for (ProtocolState state : values()) {
        if (state.id == id) {
            return state;
        }
    }
    return null;
}
```
- 根据ID查找状态
- 遍历所有状态,找到匹配的

### 使用示例

```java
// 获取状态
ProtocolState state = ProtocolState.LOGIN;
System.out.println("状态ID: " + state.getId());  // 输出: 2

// 根据ID获取状态
ProtocolState state2 = ProtocolState.fromId(2);
System.out.println("状态: " + state2);  // 输出: LOGIN

// 状态转换
ProtocolState currentState = ProtocolState.HANDSHAKING;
System.out.println("当前状态: " + currentState);

// 发送 Handshake 后,转换到 LOGIN
currentState = ProtocolState.LOGIN;
System.out.println("新状态: " + currentState);
```

## 3.7 数据包注册表

### 为什么需要注册表?

当我们接收到一个数据包时:
1. 我们知道数据包ID (例如: 0x00)
2. 我们知道当前状态 (例如: PLAY)
3. 但我们不知道应该创建哪个类的对象

**注册表就是一个"字典",告诉我们ID对应哪个类**。

### 设计注册表

```java
package protocol;

import protocol.packets.handshake.*;
import protocol.packets.play.*;

import java.util.HashMap;
import java.util.Map;

public class PacketRegistry {
    // 客户端发送的数据包 (Serverbound)
    private static final Map<ProtocolState, Map<Integer, Class<? extends Packet>>> serverbound = new HashMap<>();

    // 服务器发送的数据包 (Clientbound)
    private static final Map<ProtocolState, Map<Integer, Class<? extends Packet>>> clientbound = new HashMap<>();

    // 静态初始化块,注册所有数据包
    static {
        // 注册 HANDSHAKING 状态的数据包
        registerServerbound(ProtocolState.HANDSHAKING, 0x00, PacketHandshake.class);

        // 注册 PLAY 状态的数据包
        registerServerbound(ProtocolState.PLAY, 0x00, PacketKeepAlive.class);
        registerClientbound(ProtocolState.PLAY, 0x00, PacketKeepAlive.class);
    }

    // 注册客户端发送的数据包
    private static void registerServerbound(ProtocolState state, int id, Class<? extends Packet> packetClass) {
        serverbound.computeIfAbsent(state, k -> new HashMap<>()).put(id, packetClass);
    }

    // 注册服务器发送的数据包
    private static void registerClientbound(ProtocolState state, int id, Class<? extends Packet> packetClass) {
        clientbound.computeIfAbsent(state, k -> new HashMap<>()).put(id, packetClass);
    }

    // 创建数据包对象
    public static Packet createPacket(ProtocolState state, int packetId) {
        // 从 clientbound 查找
        Map<Integer, Class<? extends Packet>> packets = clientbound.get(state);
        if (packets == null) return null;

        Class<? extends Packet> packetClass = packets.get(packetId);
        if (packetClass == null) return null;

        try {
            // 使用反射创建对象
            return packetClass.newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

**详细解释**:

```java
private static final Map<ProtocolState, Map<Integer, Class<? extends Packet>>> serverbound = new HashMap<>();
```
- 外层 Map: 状态 → 内层 Map
- 内层 Map: 数据包ID → 数据包类

结构:
```
serverbound = {
    HANDSHAKING: {
        0x00: PacketHandshake.class
    },
    PLAY: {
        0x00: PacketKeepAlive.class
    }
}
```

```java
static {
    registerServerbound(ProtocolState.HANDSHAKING, 0x00, PacketHandshake.class);
}
```
- 静态初始化块
- 程序启动时自动执行
- 注册所有数据包

```java
serverbound.computeIfAbsent(state, k -> new HashMap<>()).put(id, packetClass);
```
- `computeIfAbsent`: 如果 key 不存在,创建一个新的 HashMap
- `put`: 将 ID 和类关联起来

```java
return packetClass.newInstance();
```
- 使用反射创建对象
- 相当于 `new PacketKeepAlive()`

### 使用示例

```java
// 接收数据包
byte[] data = ...; // 从网络接收
PacketBuffer buffer = new PacketBuffer(data);

// 读取数据包ID
int packetId = buffer.readVarInt();

// 根据状态和ID创建数据包对象
ProtocolState currentState = ProtocolState.PLAY;
Packet packet = PacketRegistry.createPacket(currentState, packetId);

if (packet != null) {
    // 读取数据
    packet.read(buffer);

    // 处理数据包
    if (packet instanceof PacketKeepAlive) {
        PacketKeepAlive keepAlive = (PacketKeepAlive) packet;
        System.out.println("收到 KeepAlive: " + keepAlive.getKeepAliveId());
    }
} else {
    System.out.println("未知的数据包ID: " + packetId);
}
```

## 3.8 小结

**我们实现了什么?**

1. ✅ Packet 接口: 定义数据包的基本方法
2. ✅ PacketKeepAlive: 实现简单的数据包
3. ✅ PacketHandshake: 实现复杂的数据包
4. ✅ ProtocolState: 协议状态枚举
5. ✅ PacketRegistry: 数据包注册表

**数据包系统的核心**:
- 接口定义规范
- 每个数据包实现接口
- 注册表管理所有数据包
- 使用反射动态创建对象

**下一章预告**:
我们将实现网络连接类,真正开始与服务器通信!

---

## 练习题

1. 实现一个 PacketChatMessage 数据包,包含一个字符串字段
2. 为什么需要两个构造函数(无参和有参)?
3. 注册表中为什么要区分 serverbound 和 clientbound?

**答案**:
1. 参考 PacketKeepAlive,将 int 改为 String
2. 无参构造用于接收(先创建空对象,再 read),有参构造用于发送(直接创建带数据的对象)
3. 因为客户端发送和服务器发送的数据包ID可能相同,但类型不同
