# 第4章: 实现网络连接

## 4.1 TCP Socket 编程基础

### 什么是 Socket?

Socket 就像一个电话:
- 你拨号连接对方(建立连接)
- 你说话(发送数据)
- 你听对方说话(接收数据)
- 你挂断电话(关闭连接)

### Java Socket 基础

```java
// 1. 创建 Socket,连接到服务器
Socket socket = new Socket("localhost", 25565);

// 2. 获取输入流和输出流
InputStream input = socket.getInputStream();
OutputStream output = socket.getOutputStream();

// 3. 发送数据
output.write(new byte[]{1, 2, 3});
output.flush();  // 立即发送

// 4. 接收数据
byte[] buffer = new byte[1024];
int length = input.read(buffer);

// 5. 关闭连接
socket.close();
```

**详细解释**:

```java
Socket socket = new Socket("localhost", 25565);
```
- `"localhost"`: 服务器地址(本机)
- `25565`: 端口号(Minecraft 默认端口)
- 这行代码会阻塞,直到连接成功或失败

```java
output.flush();
```
- 强制发送缓冲区中的数据
- 不调用 flush,数据可能停留在缓冲区

## 4.2 MinecraftConnection 类设计

### 类的职责

MinecraftConnection 负责:
1. 建立和管理 TCP 连接
2. 发送数据包
3. 接收数据包
4. 处理压缩
5. 处理加密

### 类的结构

```java
public class MinecraftConnection {
    // 网络连接
    private Socket socket;
    private InputStream rawInput;
    private OutputStream rawOutput;
    private DataInputStream input;
    private DataOutputStream output;

    // 协议状态
    private ProtocolState state;

    // 压缩
    private int compressionThreshold = -1;

    // 加密
    private boolean encrypted = false;
}
```

## 4.3 建立连接

### 步骤1: 创建构造函数

```java
package network;

import protocol.*;

import java.io.*;
import java.net.Socket;

public class MinecraftConnection {
    private Socket socket;
    private InputStream rawInput;
    private OutputStream rawOutput;
    private DataInputStream input;
    private DataOutputStream output;
    private ProtocolState state;
    private int compressionThreshold = -1;
    private boolean encrypted = false;

    public MinecraftConnection(String host, int port) throws IOException {
        // 1. 创建 Socket 连接
        this.socket = new Socket(host, port);

        // 2. 获取原始流(用于加密)
        this.rawInput = socket.getInputStream();
        this.rawOutput = socket.getOutputStream();

        // 3. 包装成 DataInputStream/DataOutputStream
        this.input = new DataInputStream(rawInput);
        this.output = new DataOutputStream(rawOutput);

        // 4. 初始状态是 HANDSHAKING
        this.state = ProtocolState.HANDSHAKING;
    }
}
```

**详细解释**:

```java
this.rawInput = socket.getInputStream();
this.rawOutput = socket.getOutputStream();
```
- 保存原始流的引用
- 后面启用加密时需要用到

```java
this.input = new DataInputStream(rawInput);
this.output = new DataOutputStream(rawOutput);
```
- `DataInputStream`: 提供 readByte(), readInt() 等方法
- `DataOutputStream`: 提供 writeByte(), writeInt() 等方法

```java
this.state = ProtocolState.HANDSHAKING;
```
- 初始状态是 HANDSHAKING
- 连接建立后的第一个状态

### 步骤2: 添加状态管理方法

```java
public void setState(ProtocolState state) {
    this.state = state;
}

public ProtocolState getState() {
    return state;
}

public boolean isConnected() {
    return socket != null && socket.isConnected() && !socket.isClosed();
}

public void close() throws IOException {
    if (socket != null && !socket.isClosed()) {
        socket.close();
    }
}
```

## 4.4 发送数据包

### 发送流程

```
1. 创建 PacketBuffer
2. 写入数据包ID
3. 写入数据包内容
4. 如果启用压缩,压缩数据
5. 写入长度
6. 发送数据
```

### 实现代码

```java
public void sendPacket(Packet packet) throws IOException {
    // 1. 创建缓冲区
    PacketBuffer buffer = new PacketBuffer();

    // 2. 写入数据包ID
    buffer.writeVarInt(packet.getPacketId());

    // 3. 写入数据包内容
    packet.write(buffer);

    // 4. 获取字节数组
    byte[] data = buffer.toByteArray();

    // 5. 如果启用压缩,压缩数据
    if (compressionThreshold >= 0) {
        data = compressPacket(data);
    }

    // 6. 写入长度
    PacketBuffer lengthBuffer = new PacketBuffer();
    lengthBuffer.writeVarInt(data.length);

    // 7. 发送长度和数据
    output.write(lengthBuffer.toByteArray());
    output.write(data);
    output.flush();
}
```

**详细解释**:

```java
PacketBuffer buffer = new PacketBuffer();
buffer.writeVarInt(packet.getPacketId());
packet.write(buffer);
```
- 先写入ID,再写入内容
- 这是 Minecraft 协议的标准格式

```java
if (compressionThreshold >= 0) {
    data = compressPacket(data);
}
```
- 如果启用了压缩,压缩数据
- `compressionThreshold`: 压缩阈值
- 小于阈值的数据包不压缩

```java
output.write(lengthBuffer.toByteArray());
output.write(data);
output.flush();
```
- 先发送长度,再发送数据
- `flush()`: 立即发送,不等待缓冲区满

### 发送示例

```java
// 创建连接
MinecraftConnection connection = new MinecraftConnection("localhost", 25565);

// 创建 Handshake 数据包
PacketHandshake handshake = new PacketHandshake(47, "localhost", 25565, 2);

// 发送数据包
connection.sendPacket(handshake);

System.out.println("Handshake 已发送!");
```

## 4.5 接收数据包

### 接收流程

```
1. 读取数据包长度
2. 读取数据包数据
3. 如果启用压缩,解压缩数据
4. 读取数据包ID
5. 根据ID创建数据包对象
6. 读取数据包内容
```

### 实现代码

```java
public Packet receivePacket() throws IOException {
    try {
        // 1. 读取数据包长度
        int length = readVarInt(input);

        // 2. 读取数据包数据
        byte[] data = new byte[length];
        input.readFully(data);

        // 3. 如果启用压缩,解压缩
        if (compressionThreshold >= 0) {
            data = decompressPacket(data);
        }

        // 4. 创建缓冲区
        PacketBuffer buffer = new PacketBuffer(data);

        // 5. 读取数据包ID
        int packetId = buffer.readVarInt();

        // 6. 创建数据包对象
        return createPacket(packetId, buffer);
    } catch (java.io.EOFException e) {
        // 连接关闭
        return null;
    }
}

private Packet createPacket(int packetId, PacketBuffer buffer) throws IOException {
    // 从注册表创建数据包
    Packet packet = PacketRegistry.createPacket(state, packetId);
    if (packet != null) {
        // 读取数据包内容
        packet.read(buffer);
    }
    return packet;
}
```

**详细解释**:

```java
int length = readVarInt(input);
```
- 先读取长度
- 知道要读取多少字节

```java
input.readFully(data);
```
- `readFully`: 读取指定数量的字节
- 如果数据不够,会阻塞等待

```java
catch (java.io.EOFException e) {
    return null;
}
```
- `EOFException`: 连接关闭或数据不足
- 返回 null 表示没有数据包

### 读取 VarInt 的辅助方法

```java
private int readVarInt(DataInputStream input) throws IOException {
    int value = 0;
    int position = 0;
    byte currentByte;

    while (true) {
        currentByte = input.readByte();
        value |= (currentByte & 127) << position;

        if ((currentByte & 128) == 0) break;

        position += 7;

        if (position >= 32) throw new RuntimeException("VarInt is too big");
    }

    return value;
}
```

### 接收示例

```java
// 接收数据包
Packet packet = connection.receivePacket();

if (packet == null) {
    System.out.println("连接关闭");
} else if (packet instanceof PacketKeepAlive) {
    PacketKeepAlive keepAlive = (PacketKeepAlive) packet;
    System.out.println("收到 KeepAlive: " + keepAlive.getKeepAliveId());

    // 立即回复
    connection.sendPacket(new PacketKeepAlive(keepAlive.getKeepAliveId()));
}
```

## 4.6 数据包压缩

### 为什么需要压缩?

- Minecraft 世界数据很大(区块、实体等)
- 压缩可以减少网络流量
- 提高传输速度

### 压缩格式

```
未压缩:
[数据包长度] [数据包ID] [数据内容]

压缩后:
[数据包长度] [未压缩长度] [压缩后的数据]
```

**注意**:
- 如果数据包小于阈值,不压缩
- 未压缩长度为 0 表示没有压缩

### 实现压缩

```java
private byte[] compressPacket(byte[] data) throws IOException {
    PacketBuffer buffer = new PacketBuffer();

    // 如果数据大于等于阈值,压缩
    if (data.length >= compressionThreshold) {
        // 写入未压缩长度
        buffer.writeVarInt(data.length);

        // 使用 zlib 压缩
        Deflater deflater = new Deflater();
        deflater.setInput(data);
        deflater.finish();

        ByteArrayOutputStream compressed = new ByteArrayOutputStream();
        byte[] temp = new byte[8192];
        while (!deflater.finished()) {
            int count = deflater.deflate(temp);
            compressed.write(temp, 0, count);
        }
        deflater.end();

        // 写入压缩后的数据
        buffer.writeBytes(compressed.toByteArray());
    } else {
        // 不压缩,写入 0
        buffer.writeVarInt(0);
        buffer.writeBytes(data);
    }

    return buffer.toByteArray();
}
```

**详细解释**:

```java
if (data.length >= compressionThreshold)
```
- 只有大于等于阈值的数据包才压缩
- 小数据包压缩反而会变大

```java
Deflater deflater = new Deflater();
deflater.setInput(data);
deflater.finish();
```
- `Deflater`: Java 的 zlib 压缩器
- `setInput`: 设置要压缩的数据
- `finish`: 完成压缩

```java
while (!deflater.finished()) {
    int count = deflater.deflate(temp);
    compressed.write(temp, 0, count);
}
```
- 循环读取压缩后的数据
- 每次最多读取 8192 字节

### 实现解压缩

```java
private byte[] decompressPacket(byte[] data) throws IOException {
    PacketBuffer buffer = new PacketBuffer(data);

    // 读取未压缩长度
    int uncompressedSize = buffer.readVarInt();

    // 如果是 0,表示没有压缩
    if (uncompressedSize == 0) {
        return buffer.readBytes(buffer.getReadableBytes());
    }

    // 读取压缩后的数据
    byte[] compressed = buffer.readBytes(buffer.getReadableBytes());

    // 使用 zlib 解压缩
    Inflater inflater = new Inflater();
    inflater.setInput(compressed);

    byte[] uncompressed = new byte[uncompressedSize];
    try {
        inflater.inflate(uncompressed);
    } catch (Exception e) {
        throw new IOException("Failed to decompress packet", e);
    }
    inflater.end();

    return uncompressed;
}
```

**详细解释**:

```java
if (uncompressedSize == 0) {
    return buffer.readBytes(buffer.getReadableBytes());
}
```
- 未压缩长度为 0,表示没有压缩
- 直接返回剩余数据

```java
Inflater inflater = new Inflater();
inflater.setInput(compressed);
inflater.inflate(uncompressed);
```
- `Inflater`: Java 的 zlib 解压缩器
- `inflate`: 解压缩到指定数组

### 设置压缩阈值

```java
public void setCompressionThreshold(int threshold) {
    this.compressionThreshold = threshold;
    System.out.println("压缩已启用,阈值: " + threshold);
}
```

## 4.7 加密支持

### 为什么需要加密?

- 防止数据被窃听
- 防止数据被篡改
- 局域网服务器需要加密

### 加密流程

```
1. 服务器发送公钥和验证令牌
2. 客户端生成 AES 密钥
3. 客户端用服务器公钥加密 AES 密钥和验证令牌
4. 客户端发送加密后的数据
5. 双方启用 AES 加密
```

### 实现加密

```java
import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;

public void enableEncryption(SecretKey sharedSecret) throws Exception {
    // 创建加密和解密的 Cipher
    Cipher encryptCipher = createAESCipher(Cipher.ENCRYPT_MODE, sharedSecret);
    Cipher decryptCipher = createAESCipher(Cipher.DECRYPT_MODE, sharedSecret);

    // 包装输入输出流
    this.output = new DataOutputStream(new CipherOutputStream(rawOutput, encryptCipher));
    this.input = new DataInputStream(new CipherInputStream(rawInput, decryptCipher));

    this.encrypted = true;
    System.out.println("加密已启用");
}

private Cipher createAESCipher(int mode, SecretKey key) throws Exception {
    // 创建 AES/CFB8/NoPadding 模式的 Cipher
    Cipher cipher = Cipher.getInstance("AES/CFB8/NoPadding");

    // 初始化 Cipher
    cipher.init(mode, key, new javax.crypto.spec.IvParameterSpec(key.getEncoded()));

    return cipher;
}
```

**详细解释**:

```java
Cipher.getInstance("AES/CFB8/NoPadding");
```
- `AES`: 加密算法
- `CFB8`: 加密模式(8位密文反馈)
- `NoPadding`: 不填充

```java
new CipherOutputStream(rawOutput, encryptCipher)
```
- `CipherOutputStream`: 自动加密写入的数据
- 写入的数据会自动加密后发送

```java
new CipherInputStream(rawInput, decryptCipher)
```
- `CipherInputStream`: 自动解密读取的数据
- 读取的数据会自动解密

### 加密示例

```java
// 接收加密请求
PacketEncryptionRequest request = ...;

// 生成 AES 密钥
SecretKey sharedSecret = MinecraftEncryption.generateSharedSecret();

// 用服务器公钥加密
PublicKey publicKey = MinecraftEncryption.decodePublicKey(request.getPublicKey());
byte[] encryptedSecret = MinecraftEncryption.encryptRSA(publicKey, sharedSecret.getEncoded());
byte[] encryptedToken = MinecraftEncryption.encryptRSA(publicKey, request.getVerifyToken());

// 发送加密响应
PacketEncryptionResponse response = new PacketEncryptionResponse(encryptedSecret, encryptedToken);
connection.sendPacket(response);

// 启用加密
connection.enableEncryption(sharedSecret);
```

## 4.8 完整代码

```java
package network;

import protocol.*;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;
import java.io.*;
import java.net.Socket;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

public class MinecraftConnection {
    private Socket socket;
    private InputStream rawInput;
    private OutputStream rawOutput;
    private DataInputStream input;
    private DataOutputStream output;
    private ProtocolState state;
    private int compressionThreshold = -1;
    private boolean encrypted = false;

    public MinecraftConnection(String host, int port) throws IOException {
        this.socket = new Socket(host, port);
        this.rawInput = socket.getInputStream();
        this.rawOutput = socket.getOutputStream();
        this.input = new DataInputStream(rawInput);
        this.output = new DataOutputStream(rawOutput);
        this.state = ProtocolState.HANDSHAKING;
    }

    public void sendPacket(Packet packet) throws IOException {
        PacketBuffer buffer = new PacketBuffer();
        buffer.writeVarInt(packet.getPacketId());
        packet.write(buffer);

        byte[] data = buffer.toByteArray();

        if (compressionThreshold >= 0) {
            data = compressPacket(data);
        }

        PacketBuffer lengthBuffer = new PacketBuffer();
        lengthBuffer.writeVarInt(data.length);

        output.write(lengthBuffer.toByteArray());
        output.write(data);
        output.flush();
    }

    public Packet receivePacket() throws IOException {
        try {
            int length = readVarInt(input);
            byte[] data = new byte[length];
            input.readFully(data);

            if (compressionThreshold >= 0) {
                data = decompressPacket(data);
            }

            PacketBuffer buffer = new PacketBuffer(data);
            int packetId = buffer.readVarInt();

            return createPacket(packetId, buffer);
        } catch (java.io.EOFException e) {
            return null;
        }
    }

    private Packet createPacket(int packetId, PacketBuffer buffer) throws IOException {
        Packet packet = PacketRegistry.createPacket(state, packetId);
        if (packet != null) {
            packet.read(buffer);
        }
        return packet;
    }

    private byte[] compressPacket(byte[] data) throws IOException {
        PacketBuffer buffer = new PacketBuffer();

        if (data.length >= compressionThreshold) {
            buffer.writeVarInt(data.length);

            Deflater deflater = new Deflater();
            deflater.setInput(data);
            deflater.finish();

            ByteArrayOutputStream compressed = new ByteArrayOutputStream();
            byte[] temp = new byte[8192];
            while (!deflater.finished()) {
                int count = deflater.deflate(temp);
                compressed.write(temp, 0, count);
            }
            deflater.end();

            buffer.writeBytes(compressed.toByteArray());
        } else {
            buffer.writeVarInt(0);
            buffer.writeBytes(data);
        }

        return buffer.toByteArray();
    }

    private byte[] decompressPacket(byte[] data) throws IOException {
        PacketBuffer buffer = new PacketBuffer(data);
        int uncompressedSize = buffer.readVarInt();

        if (uncompressedSize == 0) {
            return buffer.readBytes(buffer.getReadableBytes());
        }

        byte[] compressed = buffer.readBytes(buffer.getReadableBytes());
        Inflater inflater = new Inflater();
        inflater.setInput(compressed);

        byte[] uncompressed = new byte[uncompressedSize];
        try {
            inflater.inflate(uncompressed);
        } catch (Exception e) {
            throw new IOException("Failed to decompress packet", e);
        }
        inflater.end();

        return uncompressed;
    }

    public void enableEncryption(SecretKey sharedSecret) throws Exception {
        Cipher encryptCipher = createAESCipher(Cipher.ENCRYPT_MODE, sharedSecret);
        Cipher decryptCipher = createAESCipher(Cipher.DECRYPT_MODE, sharedSecret);

        this.output = new DataOutputStream(new CipherOutputStream(rawOutput, encryptCipher));
        this.input = new DataInputStream(new CipherInputStream(rawInput, decryptCipher));
        this.encrypted = true;
    }

    private Cipher createAESCipher(int mode, SecretKey key) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/CFB8/NoPadding");
        cipher.init(mode, key, new javax.crypto.spec.IvParameterSpec(key.getEncoded()));
        return cipher;
    }

    private int readVarInt(DataInputStream input) throws IOException {
        int value = 0;
        int position = 0;
        byte currentByte;

        while (true) {
            currentByte = input.readByte();
            value |= (currentByte & 127) << position;

            if ((currentByte & 128) == 0) break;

            position += 7;

            if (position >= 32) throw new RuntimeException("VarInt is too big");
        }

        return value;
    }

    public void setState(ProtocolState state) {
        this.state = state;
    }

    public ProtocolState getState() {
        return state;
    }

    public void setCompressionThreshold(int threshold) {
        this.compressionThreshold = threshold;
    }

    public void close() throws IOException {
        if (socket != null && !socket.isClosed()) {
            socket.close();
        }
    }

    public boolean isConnected() {
        return socket != null && socket.isConnected() && !socket.isClosed();
    }
}
```

## 4.9 小结

**我们实现了什么?**

1. ✅ TCP Socket 连接
2. ✅ 发送数据包
3. ✅ 接收数据包
4. ✅ 数据包压缩
5. ✅ 加密支持

**MinecraftConnection 的核心功能**:
- 管理网络连接
- 处理数据包的序列化和反序列化
- 支持压缩和加密
- 提供简单的 API

**下一章预告**:
我们将实现完整的登录流程,真正连接到 Minecraft 服务器!

---

## 练习题

1. 为什么需要 flush()?
2. 压缩阈值是什么意思?
3. 加密后,数据包格式有变化吗?

**答案**:
1. flush() 强制发送缓冲区中的数据,否则数据可能停留在缓冲区,导致延迟
2. 压缩阈值是指数据包大小超过这个值才压缩,小数据包压缩反而会变大
3. 没有变化,只是数据内容被加密了,格式还是 [长度][数据]
